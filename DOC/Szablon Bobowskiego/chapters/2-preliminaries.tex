\chapter{Preliminaries}
\thispagestyle{chapterBeginStyle}


\section{Credential System Definitions}
To formalize the design process of credential system we state necessary definitions. At the end we present some examples to give proper intuition for used terms. 

\begin{definition}[Credential]
Credential is a statement, issued by an issuing entity, representing a relationship with the user (possibly based on some attributes). Credentials are presented to the verifying entities.
\end{definition}

\begin{definition}[Credential Type]
Credential type is a class of credentials representing the same statement with no relation to a user.
\end{definition}

\begin{example}[Driver's license]
\textbf{Statement:} "Owner is allowed to drive following vehicles: ... ".
\textbf{User:} Owner of the document. 
\textbf{Issuer:} Department of motor vehicles.
\textbf{Verifier:} e.g. Police (represented by a police officer). 
\textbf{Credential type:} "driving permission".
\end{example}

\begin{definition}[Credential System]
Credential system consists of three interacting parties: users, issuers and verifying entities. Such system must provide functionality for credential issuance and verification. Addition of new users and other entities should be possible.
\end{definition}

\begin{example}[Cinema ticket discounts for students]
In some cinemas there is a price discount for students. To obtain it one has to present valid student ID. In this scenario the university is the issuing entity (Note that there are more than one university) and the cinema is the verifier (represented by a worker selling tickets). It is important to notice that the verifying entity may be an issuer of another credential (cinema ticket), this gives natural flow to the whole system.
\end{example}

\begin{definition}[Non-transferable Credential]
A non-transferable credential is a credential that is uniquely associated with the owner and cannot be transferred to another user without transferring their identity.
\end{definition}

\begin{example}[Public transport]
There are many types of tickets one can buy in Wrocław. The one-time ticket is an example of transferable credential in the sense that one can give it to another person after validating it and it remains valid for that person (we do not consider here the question whether it is legal, only that it is possible). It is not bound to ones name.

But the monthly ticket is connected with the identity of the holder (name and photo) because it has to be encoded on Urban Card (electronic document for public communication in Wrocław). In this case one would have to share the "visual identity" (photo) with the other person.
\end{example}

\begin{definition}[Anonymous Credential System]
In anonymous credential system user upon presentation of credential to verifying entity reveals no other information than the fact that he is in possession of valid credential issued by a legitimate authority. It is infeasable for any party (or a colluding group of parties) to learn more about the user than he agreed to during credential presentation. Such system must provide functionality for:
\begin{enumerate}
    \item Issuance of credentials,
    \item Verification of credentials.
\end{enumerate}
\end{definition}

\begin{definition}[Pseudonymous Credential System]
Pseudonymous credential system is a sub-class of anonymous credential system in which a pseudonym is uniquely established between a user and an issuing (and, if required by system design, a verifying) organization. Issuers and verifying entities know users only by pseudonyms and it is infeasable for any party (or a colluding group of parties) to learn more about the user than he agreed to during credential presentation. Such system must provide functionality for:
\begin{enumerate}
    \item Registration with an organization (obtaining valid pseudonym),
    \item Issue of credentials for pseudonym,
    \item Transfer of credentials (between pseudonyms of the same user),
    \item Verification of credentials.
\end{enumerate}
\end{definition}

\begin{definition}[One-show Credential]
A one-show credential is a credential which may be presented only once by the owner without compromising the properties and security of the system. For subsequent presentations reissuing is required to preserve system properties.
\end{definition}

\begin{definition}[Multiple-show Credential]
A multiple-show credential is a credential which may be presented multiple times by the owner without compromising the properties and security of the system.
\end{definition}

\begin{definition}[PPT entities]
Each party in a credential system i.e users, issuers and verifiers, are probabilistic polynomial time Turing machines ($\textit{PPT}_{\textit{TM}}$) 
\end{definition}



\section{Cryptographic Assumptions}

% \begin{definition}[Notation]
% We will use elliptic curve notation of group operations. That is:
% \begin{itemize}
%     \item $(\Group, q, G)$ is a tuple of cyclic group or order $q$ with generator $G$,
%     \item $A, B \in \Group \quad A + B$ refers to point addition,
%     \item $A, B \in \Group \quad A - B$ refers to point subtraction,
%     \item $x \in \ZZ_q, A \in \Group \quad [x]G$ refers to point multiplication.
% \end{itemize}
% In other cases we will also refer to integer field notation of point exponentiation, but assuming its ordinarity the detailed description will be ommited. 
% \end{definition}

\begin{assumption}[Discrete Logarithm (DL)]
The discrete logarithm problem is hard relative to $\setup$ if for all \textsc{PPT} algorithms \adv
% the following is negligible:
$$\prob{(\Group, q, g) \gets \setup(\secparam); h \gets \Group; x \gets \adv(\Group, q, g, h): g^x = h} \leq \varepsilon $$
for a negligible $\varepsilon$. 
The discrete logarithm assumption is that there exists $\setup$ relative to which the discrete logarithm problem is hard.
\end{assumption}

\begin{assumption}[Discrete Logarithm Relation]
The discrete logarithm relation problem is hard relative to $\setup$ if for all \textsc{PPT} algorithms \adv
% the following is negligible:
$$\prob{(\Group, q) \gets \setup(\secparam); g_1, \dots g_n \sample \Group; a_1, \dots a_n \gets \adv(\Group, q, g_1, \dots g_n): \exists a_i \neq 0 \wedge \prod_{i=1}^n g_i^{a_i} = 1} \leq \varepsilon $$
for a negligible $\varepsilon$. 
We say $\prod_{i=1}^n g_i^{a_i} = 1$ is a non trivial discrete logarithm relation between $g_1, \dots g_n$. 
The discrete logarithm relation assumption is that it is infeasable to find non-trivial relation between randomly chosen group elements. For $n \geq 1$ this is equivalent to the discrete logarithm assumption.
\end{assumption}

\begin{assumption}[Computational Diffie-Hellman (CDH)]
The computational Diffie-Hellman problem is hard relative to $\setup$ if for all \textsc{PPT} algorithms \adv
$$\prob{(\Group, q, g) \gets \setup(\secparam); a, b \sample \ZZ_q; g^{ab} \gets \adv(\Group, q, g, g^a, g^b)} \leq \varepsilon$$
for a negligible $\varepsilon$.
The computational Diffie-Hellman assumption is that there exists $\setup$ relative to which the computational Diffie-Hellman problem is hard.
\end{assumption}

\begin{assumption}[Decisional Diffie-Hellman (DDH)]
The decisional Diffie-Hellman problem is hard relative to $\setup$ if for all \textsc{PPT} algorithms \adv
$$ \abs{ \prob{\text{True} \gets \adv(\Group, q, g, g^a, g^b, g^{ab})} - \prob{\text{True} \gets \adv(\Group, q, g, g^a, g^b, g^c)} } \leq \varepsilon $$
for a negligible $\varepsilon$, 
where $(\Group, q, g) \gets \setup(\secparam)$, and $a, b, c \sample \ZZ_q$.

The decisional Diffie-Hellman assumption is that there exists $\setup$ relative to which the decisional Diffie-Hellman problem is hard.
\end{assumption}

% \begin{definition}[Bilinear Maps]
% Suppose that $\setup(\secparam)$ outputs the setup for $(\Group, +)$ with generator $G$ and $(\Group_T, \cdot)$ with generator $\widetilde G$, such that $\abs{\langle G \rangle} = \abs{\langle \widetilde G \rangle} = q$ where $q$ is prime. Let $e: \Group \times \Group \rightarrow \Group_T$ be be a function such that:
% \begin{enumerate}
%     \item (Bilinear) $(\forall A, B \in \Group)(\forall x, y \in \ZZ_q) \quad e([x]A, [y]B) = e(A, B)^{xy}$.
%     \item (Non-degenerate) $\exists P, Q \in \Group$ s.t. $e(P,Q) \neq 1$, where $1$ is the identity of $G_T$.
%     \item (Efficient) There exists an efficient algorithm for computing $e$.
% \end{enumerate}
% We write: $(q, \Group, G, \Group_T, \widetilde G, e) \gets \setup(\secparam)$.
% \end{definition}
% Note, that because $e([a]G, [b]G) = e(G, G)^{ab} = e(G, [ab]G)$ holds in groups with bilinear pairings, the Decisional Diffie-Hellman problem is easily solved in such groups.

\begin{definition}[Bilinear Maps]
Let $(q, \Group_1, \Group_2, \Group_T, e) \gets \setup(\secparam)$, such that $\Group_1$ and $\Group_2$ are two additive cyclic groups of order $q$. We say that $e$ is a bilinear map, if for multiplicative group $\Group_T$, $e: \Group_1 \times \Group_2 \rightarrow \Group_T$ such that:
\begin{enumerate}
    \item (Bilinear) $(\forall A, B \in \Group)(\forall x, y \in \ZZ_q) \quad e([x]A, [y]B) = e(A, B)^{xy}$.
    \item (Non-degenerate) $\exists P, Q \in \Group$ s.t. $e(P,Q) \neq 1$, where $1$ is the identity of $G_T$.
    \item (Efficient) There exists an efficient algorithm for computing $e$.
\end{enumerate}
\end{definition}

\begin{definition}[Type 1 Pairing]
We say, that a bilinear pairing is a Type 1 Pairing, if $\Group_1 = \Group_2$.
\end{definition}

\begin{definition}[Type 2 Pairing]
We say, that a bilinear pairing is a Type 2 Pairing, if $\Group_1 \neq \Group_2$, but there exists an efficiently computable homomorphism $\phi: \Group_1 \rightarrow \Group_2$.
\end{definition}

\begin{definition}[Type 3 Pairing]
We say, that a bilinear pairing is a Type 3 Pairing, if $\Group_1 \neq \Group_2$, and there are no efficiently computable homomorphisms from $\Group_1 \rightarrow \Group_2$.
\end{definition}
Note, that in type 1 and 2 pairings Decisional Diffie-Hellman problem is easily solved. Because $e([a]G_1, [b]G_2) = e(G_1, G_2)^{ab} = e(G_1, [ab]G_2)$.

\begin{assumption}[LRSW assumption \cite{pseudonym-systems}] \label{def:lrsw}
Let $(q, \Group, G) \gets \setup(\secparam)$. Let $A = [a]G, B = [b]G \in \Group$. Let $O_{A, B}(\cdot)$ be an oracle that on input $m \in \ZZ_q$ outputs $(R, [b]R, [a + mab]R)$ for a randomly chosen $R \in \Group$. Then for all \textsc{PPT} algorithms \adv, the following is negligible:
\begin{multline*}
\prob{} \Big[ (m, X, Y, Z) \gets \adv^{O_{A, B}} (q, \Group, G, A, B): \\ 
m \notin Q \wedge m \in \ZZ_q \wedge m \neq 0 \wedge X \in \Group \wedge Y = [b]X \wedge Z = [a + mab]X \Big] \leq \varepsilon
\end{multline*}
for a negligible $\varepsilon$, where $Q$ is the set of previous queries that $\adv$ made to $O_{A, B}(\cdot)$.
\end{assumption}


\section{Chosen Cryptographic Primitives}

% \subsection{Zero-Knowledge Proof of Knowledge (ZKP)}
\begin{definition}[Zero-Knowledge Proof of Knowledge (ZKP)]
A zero-knowledge proof of knowledge is a protocol between two \textsc{PPT} entities called Prover and Verifier. The Prover proves to the verifier that he knows a set of values without revealing these values. 

We use notation introduced by Camenish and Stadler \cite{cs-notation-zkp} for various proofs of knowledge. For instance,
$$\textit{ZKP } \set{ (\alpha, \beta, \gamma): y = g^\alpha h^\beta \wedge \widetilde y = \widetilde g^\alpha \widetilde h^\gamma \wedge (u \leq \alpha \leq v) }$$
denotes a "zero-knowledge" Proof of Knowledge of values $\alpha, \beta$ and $\gamma$ such that $y = g^\alpha h^\beta$ and $\widetilde y = \widetilde g^\alpha \widetilde h^\gamma$ holds, where $u \leq \alpha \leq v$", where $y, g, h, \widetilde y, \widetilde g$ and $\widetilde h$ are elements of some groups $\Group = \langle g \rangle = \langle h \rangle$ and $\widetilde \Group = \langle \widetilde g \rangle = \langle \widetilde h \rangle $. Greek letters denote quantities the knowledge of which is being proved, while all other parameters are known to the verifier.
\end{definition}

% \subsection{Signature Scheme}
\begin{definition}[Signature Scheme]
A signature scheme consists of three \textsc{PPT} algorithms $(\kgen, \sig, \verify)$ such that:
\begin{itemize}
    \item The key generation algorithm $\kgen$, takes as input a security parameter $\secpar$ and outputs a pair of keys $(\sk, \pk)$. These are called secret key and public key respectively.
    \item The signature algorithm $\sig$, which produces a signature $\sigma$ using private key and message $m$ from a message space. We write this as $\sigma \gets \sig_{sk}(m)$.
    \item The verification algorithm $\verify$, which tests whether $\sigma$ is a valid signature for message $m$ using public key $\pk$. That is $b \gets \verify_\pk(m, \sigma)$ where $b \in \set{0, 1}$ and $b = 1$ if and only if the signature is valid.
\end{itemize}
\end{definition}


% \subsection{Commitment Scheme}
\begin{definition}[Commitment Scheme]
A non-interactive commitment scheme consists of two \textsc{PPT} algorithms $(\setup$, $\commit)$ such that:
\begin{itemize}
    \item The setup algorithm $\setup$, which takes as input a security parameter $\secparam$ and outputs public parameters for the scheme.
    \item The commitment algorithm $\commit$, which defines a function $M \times R \rightarrow C$ for message space $M$, randomness space $R$ and commitment space $C$ determined by public parameters. $(\com = \commit(m, r))$.
\end{itemize}
% For a message $m \in M$ the algorithm samples $r \sample R$ uniformly at random, and computes commitment $\com = \commit(m, r)$.
\end{definition}

\begin{definition}[Hiding Commitment]
A commitment scheme is hiding if for all \textsc{PPT} algorithms $\adv$
\begin{multline*}
  \Bigg| \prob{} \Big[ (M, R, C) \gets \setup(\secparam); \\ m_0, m_1 \in M; b \sample \bin; r \sample R; \com = \commit(m_b, r);
  b' \gets \adv(M, R, C, \com): b = b' \Big] - \frac{1}{2} \Bigg| \leq \varepsilon
\end{multline*}
for a negligible $\varepsilon$. If it is equal to $0$ then we say the scheme is perfectly hiding.
\end{definition}

\begin{definition}[Binding Commitment]
A commitment scheme is binding if for all \textsc{PPT} algorithms $\adv$
$$ \prob{} \Big[ (M, R, C) \gets \setup(\secparam); m_0, m_1 \in M; r_0, r_1 \in R: \commit(m_0, r_0) = \commit(m_1, r_1) \wedge m_0 \neq m_1 \Big] \leq \varepsilon $$
for a negligible $\varepsilon$. If it is equal to $0$ then we say the scheme is perfectly binding.
\end{definition}

\section{Chosen Cryptographic Protocols}

% \subsection{Pedersen Commitment}
% As in \cite{pedersen-commitment}.
\begin{definition}[Pedersen Commitment \cite{pedersen-commitment}]
Defining public parameters $M, R = \ZZ_q, C = \Group$.
\begin{itemize}
    \item[] $\setup: H, G \sample \Group$ such that nobody knows $\log_G(H)$ or $\log_H(G)$.
    \item[] $\commit(m, r) = [r]H + [m]G$  
\end{itemize}
\end{definition}

% \subsection{Pedersen Vector Commitment}
\begin{definition}[Pedersen Vector Commitment]
Defining public parameters $M = \ZZ_q^n, R = \ZZ_q, C = \Group$.
\begin{itemize}
    \item[] $\setup: (G_0, G_1, \dots G_n) \sample \Group$ such that nobody knows $\log_{G_i}(G_j)$ for any $i, j \in \set{0, \dots n}$.
    \item[] $\commit((m_1, \dots, m_n), r) = [r]G_0 + \sum_{i=1}^n [m_i]G_i$
\end{itemize}
\end{definition}
The Pedersen vector commitment is perfectly hiding and computationally binding under the discrete logarithm assumption. We might also set $r = 0$, in which case the commitment is binding but not hiding.


% \subsection{Okamoto-Schnorr Protocol}
\begin{definition}[Okamoto-Schnorr Protocol]
Okamoto-Schnorr protocol \cite{Schnorr1991, okamoto} was designed as zero-knowledge identification scheme, which may be used as a realization of 
$$ ZKP\set{(\alpha, \beta): s = g^\alpha \cdot h^\beta} $$
It can be further extended to obtain proof for $n$ values:
$$ ZKP\set{(\alpha_1, \alpha_2, \dots, \alpha_n): s = g_1^{\alpha_1} \cdot g_2^{\alpha_2} \cdot \dots g_n^{\alpha_n}} $$
On figure \ref{fig:schnorr} we recall the original scheme, secure under discrete logarithm assumption.
\end{definition}
Note, that one can use Okamoto-Schnorr to proof the knowledge opening of the Pedersen and Vector Pedersen Commitment, this construction will be used in the future. 

\begin{figure}[h]
\centering

\begin{pcvstack}

\begin{pchstack}[center]
\procedure[linenumbering, width=5cm]{$\Setup(\secpar)$}{%
 (\Group, q, g_1, g_2) \gets \setup(\secparam) \\
 \pcreturn (\Group, q, g_1, g_2)
}

\pchspace

\procedure[linenumbering, width=5cm]{$\kgen(\Group, q, g_1, g_2)$}{%
 \alpha, \beta \sample \ZZ_q \\
 s = g_1^{-\alpha} g_2^{-\beta} \\
 \pk = s \\
 \sk = (\alpha, \beta) \\
 \pcreturn (\sk, \pk)
}

\end{pchstack}

\pcvspace

\procedure[width=11cm]{$\pcalgostyle{Proof}(\alpha, \beta)$}{%
  \textbf{Prover } (g_1, g_2, \alpha, \beta) \> \> \textbf{Verifier } (g_1, g_2, s)\\
  r_1, r_2 \sample \ZZ_q \> \> \\
  t = g_1^{r_1}g_2^{r_2} \> \> \\
  \> \sendmessageright*[3.5cm]{t} \> \\
  \> \> c \sample \ZZ_q \\
  \> \sendmessageleft*[3.5cm]{c} \> \\
  x_1 = r_1 + c \cdot \alpha \> \> \\
  x_2 = r_2 + c \cdot \beta \> \> \\
  \> \sendmessageright*[3.5cm]{x_1, x_2} \> \\
  \> \> t \stackrel{?}{=} g_1^{x_1}g_2^{x_2}s^c
}
\end{pcvstack}

\caption{Okamoto-Schnorr Identification Protocol}
\label{fig:schnorr}
\end{figure}

